"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _transform = _interopRequireDefault(require("../transform"));
var _gen = require("../../util/gen");
var _insert = require("../../util/insert");
var _assert = require("assert");
var _order = require("../../order");
var _constants = require("../../constants");
var _compare = require("../../util/compare");
var _identifiers = require("../../util/identifiers");
var _scope = require("../../util/scope");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * Defines all the names at the top of every lexical block.
 */
class MovedDeclarations extends _transform.default {
  constructor(o) {
    super(o, _order.ObfuscateOrder.MovedDeclarations);
  }
  match(object, parents) {
    return object.type === "VariableDeclaration" && object.kind === "var" && object.declarations.length === 1 && object.declarations[0].id.type === "Identifier";
  }
  transform(object, parents) {
    return () => {
      var _parents, _parents2;
      var forInitializeType = (0, _insert.isForInitialize)(object, parents);

      // Get the block statement or Program node
      var blockIndex = parents.findIndex(x => (0, _scope.isLexicalScope)(x));
      var block = parents[blockIndex];
      var body = block.type === "SwitchCase" ? block.consequent : block.body;
      (0, _assert.ok)(Array.isArray(body), "No body array found.");
      var bodyObject = parents[blockIndex - 2] || object;
      var index = body.indexOf(bodyObject);
      var varName = object.declarations[0].id.name;
      (0, _assert.ok)(typeof varName === "string");
      var predictableFunctionIndex = parents.findIndex(x => (0, _insert.isFunction)(x));
      var predictableFunction = parents[predictableFunctionIndex];
      var deleteStatement = false;
      if (predictableFunction && (predictableFunction.id && predictableFunction.id.name.includes(_constants.predictableFunctionTag) || predictableFunction[_constants.predictableFunctionTag]) &&
      // Must have predictableFunctionTag in the name, or on object
      predictableFunction[_constants.predictableFunctionTag] !== false &&
      // If === false, the function is deemed not predictable
      predictableFunction.params.length < 1000 &&
      // Max 1,000 parameters
      !predictableFunction.params.find(x => x.type === "RestElement") &&
      // Cannot add parameters after spread operator
      !(["Property", "MethodDefinition"].includes((_parents = parents[predictableFunctionIndex + 1]) === null || _parents === void 0 ? void 0 : _parents.type) && ((_parents2 = parents[predictableFunctionIndex + 1]) === null || _parents2 === void 0 ? void 0 : _parents2.kind) !== "init") &&
      // Preserve getter/setter methods
      !(0, _identifiers.getFunctionParameters)(predictableFunction, parents.slice(predictableFunctionIndex)).find(entry => entry[0].name === varName) // Ensure not duplicate param name
      ) {
        // Use function f(..., x, y, z) to declare name

        var value = object.declarations[0].init;
        var isPredictablyComputed = predictableFunction.body === block && !(0, _insert.isStrictModeFunction)(predictableFunction) && value && (0, _compare.isIndependent)(value, []) && (0, _compare.isMoveable)(value, [object.declarations[0], object, ...parents]);
        var defineWithValue = isPredictablyComputed;
        if (defineWithValue) {
          predictableFunction.params.push((0, _gen.AssignmentPattern)((0, _gen.Identifier)(varName), value));
          object.declarations[0].init = null;
          deleteStatement = true;
        } else {
          predictableFunction.params.push((0, _gen.Identifier)(varName));
        }
      } else {
        // Use 'var x, y, z' to declare name

        // Make sure in the block statement, and not already at the top of it
        if (index === -1 || index === 0) return;
        var topVariableDeclaration;
        if (body[0].type === "VariableDeclaration" && body[0].kind === "var") {
          topVariableDeclaration = body[0];
        } else {
          topVariableDeclaration = {
            type: "VariableDeclaration",
            declarations: [],
            kind: "var"
          };
          (0, _insert.prepend)(block, topVariableDeclaration);
        }

        // Add `var x` at the top of the block
        topVariableDeclaration.declarations.push((0, _gen.VariableDeclarator)((0, _gen.Identifier)(varName)));
      }
      var assignmentExpression = (0, _gen.AssignmentExpression)("=", (0, _gen.Identifier)(varName), object.declarations[0].init || (0, _gen.Identifier)(varName));
      if (forInitializeType) {
        if (forInitializeType === "initializer") {
          // Replace `for (var i = 0...)` to `for (i = 0...)`
          this.replace(object, assignmentExpression);
        } else if (forInitializeType === "left-hand") {
          // Replace `for (var k in...)` to `for (k in ...)`

          this.replace(object, (0, _gen.Identifier)(varName));
        }
      } else {
        if (deleteStatement && index !== -1) {
          body.splice(index, 1);
        } else {
          // Replace `var x = value` to `x = value`
          this.replace(object, (0, _gen.ExpressionStatement)(assignmentExpression));
        }
      }
    };
  }
}
exports.default = MovedDeclarations;