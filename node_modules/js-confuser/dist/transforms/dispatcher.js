"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _traverse = require("../traverse");
var _gen = require("../util/gen");
var _identifiers = require("../util/identifiers");
var _insert = require("../util/insert");
var _transform = _interopRequireDefault(require("./transform"));
var _compare = require("../util/compare");
var _random = require("../util/random");
var _probability = require("../probability");
var _constants = require("../constants");
var _order = require("../order");
var _template = _interopRequireDefault(require("../templates/template"));
var _functionLength = require("../templates/functionLength");
var _globals = require("../templates/globals");
var _scope = require("../util/scope");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * A Dispatcher processes function calls. All the function declarations are brought into a dictionary.
 *
 * ```js
 * var param1;
 * function dispatcher(key){
 *     var fns = {
 *         'fn1': function(){
 *             var [arg1] = [param1];
 *             console.log(arg1);
 *         }
 *     }
 *     return fns[key]();
 * };
 * param1 = "Hello World";
 * dispatcher('fn1'); // > "Hello World"
 * ```
 *
 * Can break code with:
 *
 * 1. testing function equality,
 * 2. using `arguments.callee`,
 * 3. using `this`
 */
class Dispatcher extends _transform.default {
  constructor(o) {
    super(o, _order.ObfuscateOrder.Dispatcher);
    // Debug mode preserves function names
    _defineProperty(this, "isDebug", false);
    _defineProperty(this, "count", void 0);
    _defineProperty(this, "functionLengthName", void 0);
    this.count = 0;
  }
  apply(tree) {
    super.apply(tree);
    if (this.options.preserveFunctionLength && this.functionLengthName) {
      (0, _insert.prepend)(tree, _functionLength.FunctionLengthTemplate.single({
        name: this.functionLengthName,
        ObjectDefineProperty: this.createInitVariable(_globals.ObjectDefineProperty, [tree])
      }));
    }
  }
  match(object, parents) {
    if ((0, _compare.isInsideType)("AwaitExpression", object, parents)) {
      return false;
    }
    return (0, _insert.isVarContext)(object) && object.type !== "ArrowFunctionExpression" && !object.$dispatcherSkip && !parents.find(x => x.$dispatcherSkip);
  }
  transform(object, parents) {
    return () => {
      if ((0, _probability.ComputeProbabilityMap)(this.options.dispatcher, mode => mode)) {
        if (object.type != "Program" && object.body.type != "BlockStatement") {
          return;
        }

        // Map of FunctionDeclarations
        var functionDeclarations = Object.create(null);

        // Array of Identifier nodes
        var identifiers = [];
        var illegalFnNames = new Set();

        // New Names for Functions
        var newFnNames = Object.create(null); // [old name]: randomized name

        var context = (0, _insert.isVarContext)(object) ? object : (0, _insert.getVarContext)(object, parents);
        var lexicalScope = (0, _insert.isFunction)(context) ? context.body : context;
        (0, _traverse.walk)(object, parents, (o, p) => {
          if (object == o) {
            // Fix 1
            return;
          }
          var c = (0, _insert.getVarContext)(o, p);
          if (o.type == "FunctionDeclaration") {
            c = (0, _insert.getVarContext)(p[0], p.slice(1));
          }
          if (context === c) {
            if (o.type == "FunctionDeclaration" && o.id.name) {
              var name = o.id.name;
              if (o.$requiresEval || o.async || o.generator || p.find(x => x.$dispatcherSkip || x.type == "MethodDefinition") || o.body.type != "BlockStatement") {
                illegalFnNames.add(name);
                return;
              }

              // Must defined in the same block as the current function being scanned
              // Solves 'let' and 'class' declaration issue
              var ls = (0, _scope.getLexicalScope)(o, p);
              if (ls !== lexicalScope) {
                illegalFnNames.add(name);
                return;
              }

              // If dupe, no routing
              if (functionDeclarations[name]) {
                illegalFnNames.add(name);
                return;
              }
              (0, _traverse.walk)(o, p, (oo, pp) => {
                if (oo.type == "Identifier" && oo.name == "arguments" || oo.type == "ThisExpression" || oo.type == "Super") {
                  if ((0, _insert.getVarContext)(oo, pp) === o) {
                    illegalFnNames.add(name);
                    return "EXIT";
                  }
                }

                // Avoid functions with function expressions as they have a different scope
                if ((oo.type === "FunctionExpression" || oo.type === "ArrowFunctionExpression") && pp.find(x => x == o.params)) {
                  illegalFnNames.add(name);
                  return "EXIT";
                }
              });
              functionDeclarations[name] = [o, p];
            }
          }
          if (o.type == "Identifier") {
            if (_constants.reservedIdentifiers.has(o.name)) {
              return;
            }
            var info = (0, _identifiers.getIdentifierInfo)(o, p);
            if (!info.spec.isReferenced) {
              return;
            }
            if (info.spec.isDefined) {
              if (info.isFunctionDeclaration) {
                if (p[0].id && (!functionDeclarations[p[0].id.name] || functionDeclarations[p[0].id.name][0] !== p[0])) {
                  illegalFnNames.add(o.name);
                }
              } else {
                illegalFnNames.add(o.name);
              }
            } else if (info.spec.isModified) {
              illegalFnNames.add(o.name);
            } else {
              identifiers.push([o, p]);
            }
          }
        });
        illegalFnNames.forEach(name => {
          delete functionDeclarations[name];
        });

        // map original name->new game
        var gen = this.getGenerator();
        Object.keys(functionDeclarations).forEach(name => {
          newFnNames[name] = this.isDebug ? "_dispatcher_" + this.count + "_" + name : gen.generate();
        });
        // set containing new name
        var set = new Set(Object.keys(newFnNames));

        // Only make a dispatcher function if it caught any functions
        if (set.size > 0) {
          if (!this.functionLengthName) {
            this.functionLengthName = this.getPlaceholder();
          }
          var payloadArg = this.getPlaceholder() + "_dispatcher_" + this.count + "_payload";
          var dispatcherFnName = this.getPlaceholder() + "_dispatcher_" + this.count + _constants.predictableFunctionTag;
          this.log(dispatcherFnName, set);
          this.count++;
          var expectedGet = gen.generate();
          var expectedClearArgs = gen.generate();
          var expectedNew = gen.generate();
          var returnProp = gen.generate();
          var newReturnMemberName = gen.generate();
          var shuffledKeys = (0, _random.shuffle)(Object.keys(functionDeclarations));
          var mapName = this.getPlaceholder();
          var cacheName = this.getPlaceholder();

          // creating the dispatcher function
          // 1. create function map
          var map = (0, _gen.VariableDeclaration)((0, _gen.VariableDeclarator)(mapName, (0, _gen.ObjectExpression)(shuffledKeys.map(name => {
            var [def, defParents] = functionDeclarations[name];
            var body = (0, _insert.getBlockBody)(def.body);
            var functionExpression = {
              ...def,
              expression: false,
              type: "FunctionExpression",
              id: null,
              params: [],
              [_constants.predictableFunctionTag]: true
            };
            this.addComment(functionExpression, name);
            if (def.params.length > 0) {
              const fixParam = param => {
                return param;
              };
              var variableDeclaration = (0, _gen.VariableDeclaration)((0, _gen.VariableDeclarator)({
                type: "ArrayPattern",
                elements: def.params.map(fixParam)
              }, (0, _gen.Identifier)(payloadArg)));
              (0, _insert.prepend)(def.body, variableDeclaration);
            }

            // For logging purposes
            var signature = name + "(" + def.params.map(x => x.name || "<>").join(",") + ")";
            this.log("Added", signature);

            // delete ref in block
            if (defParents.length) {
              (0, _insert.deleteDirect)(def, defParents[0]);
            }
            this.addComment(functionExpression, signature);
            return (0, _gen.Property)((0, _gen.Literal)(newFnNames[name]), functionExpression, false);
          }))));
          var getterArgName = this.getPlaceholder();
          var x = this.getPlaceholder();
          var y = this.getPlaceholder();
          var z = this.getPlaceholder();
          function getAccessor() {
            return (0, _gen.MemberExpression)((0, _gen.Identifier)(mapName), (0, _gen.Identifier)(x), true);
          }

          // 2. define it
          var fn = (0, _gen.FunctionDeclaration)(dispatcherFnName, [(0, _gen.Identifier)(x), (0, _gen.Identifier)(y), (0, _gen.Identifier)(z)], [
          // Define map of callable functions
          map,
          // Set returning variable to undefined
          (0, _gen.VariableDeclaration)((0, _gen.VariableDeclarator)(returnProp)),
          // Arg to clear the payload
          (0, _gen.IfStatement)((0, _gen.BinaryExpression)("==", (0, _gen.Identifier)(y), (0, _gen.Literal)(expectedClearArgs)), [(0, _gen.ExpressionStatement)((0, _gen.AssignmentExpression)("=", (0, _gen.Identifier)(payloadArg), (0, _gen.ArrayExpression)([])))], null), (0, _gen.VariableDeclaration)((0, _gen.VariableDeclarator)((0, _gen.Identifier)("lengths"), (0, _gen.ObjectExpression)(!this.options.preserveFunctionLength ? [] : shuffledKeys.map(name => {
            var [def, defParents] = functionDeclarations[name];
            return {
              key: newFnNames[name],
              value: (0, _insert.computeFunctionLength)(def.params)
            };
          }).filter(item => item.value !== 0).map(item => (0, _gen.Property)((0, _gen.Literal)(item.key), (0, _gen.Literal)(item.value)))))), (0, _template.default)(`
              function makeFn${_constants.predictableFunctionTag}(){
                var fn = function(...args){
                  ${payloadArg} = args;
                  return ${mapName}[${x}].call(this)
                }, a = lengths[${x}]

                ${this.options.preserveFunctionLength ? `if(a){
                    return ${this.functionLengthName}(fn, a)
                  }` : ""}
                
                return fn
              }
              `).single(),
          // Arg to get a function reference
          (0, _gen.IfStatement)((0, _gen.BinaryExpression)("==", (0, _gen.Identifier)(y), (0, _gen.Literal)(expectedGet)), [
          // Getter flag: return the function object
          (0, _gen.ExpressionStatement)((0, _gen.AssignmentExpression)("=", (0, _gen.Identifier)(returnProp), (0, _gen.LogicalExpression)("||", (0, _gen.MemberExpression)((0, _gen.Identifier)(cacheName), (0, _gen.Identifier)(x), true), (0, _gen.AssignmentExpression)("=", (0, _gen.MemberExpression)((0, _gen.Identifier)(cacheName), (0, _gen.Identifier)(x), true), (0, _gen.CallExpression)((0, _gen.Identifier)(`makeFn${_constants.predictableFunctionTag}`), [])))))], [
          // Call the function, return result
          (0, _gen.ExpressionStatement)((0, _gen.AssignmentExpression)("=", (0, _gen.Identifier)(returnProp), (0, _gen.CallExpression)(getAccessor(), [])))]),
          // Check how the function was invoked (new () vs ())
          (0, _gen.IfStatement)((0, _gen.BinaryExpression)("==", (0, _gen.Identifier)(z), (0, _gen.Literal)(expectedNew)), [
          // Wrap in object
          (0, _gen.ReturnStatement)((0, _gen.ObjectExpression)([(0, _gen.Property)((0, _gen.Identifier)(newReturnMemberName), (0, _gen.Identifier)(returnProp), false)]))], [
          // Return raw result
          (0, _gen.ReturnStatement)((0, _gen.Identifier)(returnProp))])]);
          (0, _insert.append)(object, fn);
          if (payloadArg) {
            (0, _insert.prepend)(object, (0, _gen.VariableDeclaration)((0, _gen.VariableDeclarator)(payloadArg, (0, _gen.ArrayExpression)([]))));
          }
          identifiers.forEach(_ref => {
            let [o, p] = _ref;
            if (o.type != "Identifier") {
              return;
            }
            var newName = newFnNames[o.name];
            if (!newName || typeof newName !== "string") {
              return;
            }
            if (!functionDeclarations[o.name]) {
              this.error(new Error("newName, missing function declaration"));
            }
            var info = (0, _identifiers.getIdentifierInfo)(o, p);
            if (info.isFunctionCall && p[0].type == "CallExpression" && p[0].callee === o) {
              // Invoking call expression: `a();`

              if (o.name == dispatcherFnName) {
                return;
              }
              this.log(`${o.name}(${p[0].arguments.map(_ => "<>").join(",")}) -> ${dispatcherFnName}('${newName}')`);
              var assignmentExpressions = [];
              var dispatcherArgs = [(0, _gen.Literal)(newName)];
              if (p[0].arguments.length) {
                assignmentExpressions = [(0, _gen.AssignmentExpression)("=", (0, _gen.Identifier)(payloadArg), (0, _gen.ArrayExpression)(p[0].arguments))];
              } else {
                dispatcherArgs.push((0, _gen.Literal)(expectedClearArgs));
              }
              var type = (0, _random.choice)(["CallExpression", "NewExpression"]);
              var callExpression = null;
              switch (type) {
                case "CallExpression":
                  callExpression = (0, _gen.CallExpression)((0, _gen.Identifier)(dispatcherFnName), dispatcherArgs);
                  break;
                case "NewExpression":
                  if (dispatcherArgs.length == 1) {
                    dispatcherArgs.push((0, _gen.Identifier)("undefined"));
                  }
                  callExpression = (0, _gen.MemberExpression)((0, _gen.NewExpression)((0, _gen.Identifier)(dispatcherFnName), [...dispatcherArgs, (0, _gen.Literal)(expectedNew)]), (0, _gen.Identifier)(newReturnMemberName), false);
                  break;
              }
              this.addComment(callExpression, "Calling " + o.name + "(" + p[0].arguments.map(x => x.name).join(", ") + ")");
              var expr = assignmentExpressions.length ? (0, _gen.SequenceExpression)([...assignmentExpressions, callExpression]) : callExpression;

              // Replace the parent call expression
              this.replace(p[0], expr);
            } else {
              // Non-invoking reference: `a`

              if (info.spec.isDefined) {
                if (info.isFunctionDeclaration) {
                  this.log("Skipped getter " + o.name + " (function declaration)");
                } else {
                  this.log("Skipped getter " + o.name + " (defined)");
                }
                return;
              }
              if (info.spec.isModified) {
                this.log("Skipped getter " + o.name + " (modified)");
                return;
              }
              this.log(`(getter) ${o.name} -> ${dispatcherFnName}('${newName}')`);
              this.replace(o, (0, _gen.CallExpression)((0, _gen.Identifier)(dispatcherFnName), [(0, _gen.Literal)(newName), (0, _gen.Literal)(expectedGet)]));
            }
          });
          (0, _insert.prepend)(object, (0, _gen.VariableDeclaration)((0, _gen.VariableDeclarator)((0, _gen.Identifier)(cacheName), (0, _template.default)(`Object.create(null)`).single().expression)));
        }
      }
    };
  }
}
exports.default = Dispatcher;