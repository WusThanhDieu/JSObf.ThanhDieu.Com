"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _constants = require("../../constants");
var _template = _interopRequireDefault(require("../../templates/template"));
var _traverse = require("../../traverse");
var _gen = require("../../util/gen");
var _insert = require("../../util/insert");
var _transform = _interopRequireDefault(require("../transform"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Expression Obfuscation runs before Control Flow Flattening
 */
class ExpressionObfuscation extends _transform.default {
  constructor(o) {
    super(o);
    _defineProperty(this, "fnName", void 0);
  }
  apply(tree) {
    super.apply(tree);
    if (typeof this.fnName === "string") {
      (0, _insert.prepend)(tree, (0, _template.default)(`
        function {fnName}(...args){
          return args[args["length"] - 1]
        }
        `).single({
        fnName: this.fnName
      }));
    }
  }
  createSequenceExpression(expressions) {
    if (!this.fnName) {
      this.fnName = this.getPlaceholder() + _constants.criticalFunctionTag;
    }
    return (0, _gen.CallExpression)((0, _gen.Identifier)(this.fnName), [...expressions]);
  }
  match(object, parents) {
    return (0, _traverse.isBlock)(object);
  }
  transform(object, parents) {
    return () => {
      var exprs = [];
      var deleteExprs = [];
      object.body.forEach((stmt, i) => {
        if (stmt.type == "ExpressionStatement" && !stmt.directive) {
          var expr = stmt.expression;
          if (expr.type == "UnaryExpression" && !(expr.operator === "typeof" && expr.argument.type === "Identifier") && exprs.length // typeof is special
          ) {
            expr.argument = (0, _gen.SequenceExpression)([...exprs, {
              ...expr.argument
            }]);
            deleteExprs.push(...exprs);
            exprs = [];
          } else {
            exprs.push(expr);
          }
        } else {
          if (exprs.length) {
            if (stmt.type == "IfStatement") {
              if (stmt.test.type == "BinaryExpression" && stmt.test.operator !== "**") {
                if (stmt.test.left.type == "UnaryExpression" && !(stmt.test.left.operator === "typeof" && stmt.test.left.argument.type === "Identifier") // typeof is special
                ) {
                  stmt.test.left.argument = this.createSequenceExpression([...exprs, {
                    ...stmt.test.left.argument
                  }]);
                } else {
                  stmt.test.left = this.createSequenceExpression([...exprs, {
                    ...stmt.test.left
                  }]);
                }
              } else if (stmt.test.type == "LogicalExpression" && stmt.test.left.type == "BinaryExpression" && stmt.test.operator !== "**" && stmt.test.left.left.type == "UnaryExpression") {
                stmt.test.left.left.argument = this.createSequenceExpression([...exprs, {
                  ...stmt.test.left.left.argument
                }]);
              } else {
                stmt.test = this.createSequenceExpression([...exprs, {
                  ...stmt.test
                }]);
              }
              deleteExprs.push(...exprs);
            } else if (stmt.type == "ForStatement" || stmt.type == "LabeledStatement" && stmt.body.type == "ForStatement") {
              var init = (stmt.type == "LabeledStatement" ? stmt.body : stmt).init;
              if (init) {
                if (init.type == "VariableDeclaration") {
                  init.declarations[0].init = this.createSequenceExpression([...exprs, {
                    ...(init.declarations[0].init || (0, _gen.Identifier)("undefined"))
                  }]);
                  deleteExprs.push(...exprs);
                } else if (init.type == "AssignmentExpression") {
                  init.right = this.createSequenceExpression([...exprs, {
                    ...(init.right || (0, _gen.Identifier)("undefined"))
                  }]);
                  deleteExprs.push(...exprs);
                }
              }
            } else if (stmt.type == "VariableDeclaration") {
              stmt.declarations[0].init = this.createSequenceExpression([...exprs, {
                ...(stmt.declarations[0].init || (0, _gen.Identifier)("undefined"))
              }]);
              deleteExprs.push(...exprs);
            } else if (stmt.type == "ThrowStatement") {
              stmt.argument = this.createSequenceExpression([...exprs, {
                ...stmt.argument
              }]);
              deleteExprs.push(...exprs);
            } else if (stmt.type == "ReturnStatement") {
              stmt.argument = this.createSequenceExpression([...exprs, {
                ...(stmt.argument || (0, _gen.Identifier)("undefined"))
              }]);
              deleteExprs.push(...exprs);
            }
          }
          exprs = [];
        }
      });
      deleteExprs.forEach(expr => {
        var index = object.body.findIndex(x => x.expression === expr);
        if (index !== -1) {
          object.body.splice(index, 1);
        }
      });
    };
  }
}
exports.default = ExpressionObfuscation;