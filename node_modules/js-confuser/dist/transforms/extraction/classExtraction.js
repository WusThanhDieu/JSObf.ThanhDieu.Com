"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _assert = require("assert");
var _traverse = require("../../traverse");
var _gen = require("../../util/gen");
var _guard = require("../../util/guard");
var _insert = require("../../util/insert");
var _scope = require("../../util/scope");
var _transform = _interopRequireDefault(require("../transform"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
class ClassExtraction extends _transform.default {
  constructor(o) {
    super(o);
  }
  match(object, parents) {
    return object.type === "ClassDeclaration" || object.type === "ClassExpression";
  }
  extractKeyString(property) {
    if (property.key.type === "Identifier" && !property.key.computed) {
      return property.key.name;
    }
    if ((0, _guard.isStringLiteral)(property.key)) {
      return property.key.value;
    }
    return null;
  }
  transform(object, parents) {
    return () => {
      var _object$id, _object$id2;
      var classBody = object.body;
      var className = ((_object$id = object.id) === null || _object$id === void 0 ? void 0 : _object$id.type) === "Identifier" && ((_object$id2 = object.id) === null || _object$id2 === void 0 ? void 0 : _object$id2.name);
      if (!className) className = this.getPlaceholder();
      var lexicalScope = (0, _scope.getLexicalScope)(object, parents);
      var superMethodName;
      for (var methodDefinition of classBody.body) {
        if (methodDefinition.type === "MethodDefinition" && methodDefinition.value.type === "FunctionExpression") {
          // Don't change constructors calling super()
          if (methodDefinition.kind === "constructor" && object.superClass) continue;
          var functionExpression = methodDefinition.value;
          var fnName = className + "_" + methodDefinition.kind + "_" + this.extractKeyString(methodDefinition) || this.getPlaceholder();
          (0, _traverse.walk)(functionExpression, [methodDefinition, object, ...parents], (o, p) => {
            if (o.type === "Super") {
              var classContext = p.find(node => (0, _insert.isClass)(node));
              if (classContext !== object) return;
              return () => {
                if (!superMethodName) {
                  superMethodName = this.getGenerator("randomized").generate();
                }
                var memberExpression = p[0];
                if (memberExpression.type === "CallExpression") {
                  throw new Error("Failed to detect super() usage");
                }
                (0, _assert.ok)(memberExpression.type === "MemberExpression");
                var propertyArg = memberExpression.computed ? memberExpression.property : ((0, _assert.ok)(memberExpression.property.type === "Identifier"), (0, _gen.Literal)(memberExpression.property.name));
                var getSuperExpression = (0, _gen.CallExpression)((0, _gen.MemberExpression)((0, _gen.ThisExpression)(), (0, _gen.Literal)(superMethodName), true), [propertyArg]);
                if (p[1].type === "CallExpression" && p[1].callee === p[0]) {
                  getSuperExpression = (0, _gen.CallExpression)((0, _gen.MemberExpression)(getSuperExpression, (0, _gen.Literal)("bind"), true), [(0, _gen.ThisExpression)()]);
                }
                this.replace(p[0], getSuperExpression);
              };
            }
          });
          var originalParams = functionExpression.params;
          var originalBody = functionExpression.body.body;
          functionExpression.body.body = [(0, _gen.ReturnStatement)((0, _gen.CallExpression)((0, _gen.MemberExpression)((0, _gen.Identifier)(fnName), (0, _gen.Literal)("apply"), true), [(0, _gen.ThisExpression)(), (0, _gen.Identifier)("arguments")]))];
          functionExpression.params = [];
          if (methodDefinition.kind === "set") {
            functionExpression.params = [(0, _gen.Identifier)(this.getPlaceholder())];
          }
          (0, _insert.prepend)(lexicalScope, (0, _gen.FunctionDeclaration)(fnName, [...originalParams], [...originalBody]));
        }
      }
      if (superMethodName) {
        classBody.body.push((0, _gen.MethodDefinition)((0, _gen.Literal)(superMethodName), (0, _gen.FunctionExpression)([(0, _gen.Identifier)("key")], [(0, _gen.ReturnStatement)((0, _gen.MemberExpression)((0, _gen.Super)(), (0, _gen.Identifier)("key"), true))]), "method", false, true));
      }
    };
  }
}
exports.default = ClassExtraction;