"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _order = require("../order");
var _template = _interopRequireDefault(require("../templates/template"));
var _traverse = require("../traverse");
var _gen = require("../util/gen");
var _insert = require("../util/insert");
var _transform = _interopRequireDefault(require("./transform"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
// JsNice.org tries to separate sequence expressions into multiple lines, this stops that.
class AntiTooling extends _transform.default {
  constructor(o) {
    super(o, _order.ObfuscateOrder.AntiTooling);
    _defineProperty(this, "fnName", void 0);
  }
  apply(tree) {
    super.apply(tree);
    if (typeof this.fnName === "string") {
      (0, _insert.prepend)(tree, (0, _template.default)(`
      function {fnName}(){
      }
      `).single({
        fnName: this.fnName
      }));
    }
  }
  match(object, parents) {
    return (0, _traverse.isBlock)(object) || object.type == "SwitchCase";
  }
  transform(object, parents) {
    return () => {
      var exprs = [];
      var deleteExprs = [];
      var body = object.type == "SwitchCase" ? object.consequent : object.body;
      const end = () => {
        function flatten(expr) {
          if (expr.type == "ExpressionStatement") {
            flatten(expr.expression);
          } else if (expr.type == "SequenceExpression") {
            expr.expressions.forEach(flatten);
          } else {
            flattened.push(expr);
          }
        }
        var flattened = [];
        exprs.forEach(flatten);
        if (flattened.length > 1) {
          flattened[0] = {
            ...flattened[0]
          };
          if (!this.fnName) {
            this.fnName = this.getPlaceholder();
          }

          // (expr1,expr2,expr3) -> F(expr1, expr2, expr3)
          this.replace(exprs[0], (0, _gen.ExpressionStatement)((0, _gen.CallExpression)((0, _gen.Identifier)(this.fnName), [...flattened])));
          deleteExprs.push(...exprs.slice(1));
        }
        exprs = [];
      };
      body.forEach((stmt, i) => {
        if (stmt.hidden || stmt.directive) {
          return;
        }
        if (stmt.type == "ExpressionStatement") {
          exprs.push(stmt);
        } else {
          end();
        }
      });
      end();
      deleteExprs.forEach(expr => {
        var index = body.indexOf(expr);
        if (index !== -1) {
          body.splice(index, 1);
        }
      });
    };
  }
}
exports.default = AntiTooling;