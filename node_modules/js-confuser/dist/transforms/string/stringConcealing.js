"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _assert = require("assert");
var _order = require("../../order");
var _template = _interopRequireDefault(require("../../templates/template"));
var _traverse = require("../../traverse");
var _compare = require("../../util/compare");
var _gen = require("../../util/gen");
var _insert = require("../../util/insert");
var _random = require("../../util/random");
var _transform = _interopRequireDefault(require("../transform"));
var _encoding = require("./encoding");
var _probability = require("../../probability");
var _bufferToString = require("../../templates/bufferToString");
var _constants = require("../../constants");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class StringConcealing extends _transform.default {
  constructor(o) {
    super(o, _order.ObfuscateOrder.StringConcealing);
    _defineProperty(this, "arrayExpression", void 0);
    _defineProperty(this, "set", void 0);
    _defineProperty(this, "index", void 0);
    // index, fnName, block
    _defineProperty(this, "arrayName", this.getPlaceholder());
    _defineProperty(this, "ignore", new Set());
    _defineProperty(this, "variablesMade", 1);
    _defineProperty(this, "gen", void 0);
    _defineProperty(this, "functionObjects", []);
    this.set = new Set();
    this.index = Object.create(null);
    this.arrayExpression = (0, _gen.ArrayExpression)([]);
    this.gen = this.getGenerator();
  }
  apply(tree) {
    super.apply(tree);

    // Pad array with useless strings
    var dead = (0, _random.getRandomInteger)(5, 15);
    for (var i = 0; i < dead; i++) {
      var str = (0, _random.getRandomString)((0, _random.getRandomInteger)(5, 40));
      var fn = this.transform((0, _gen.Literal)(str), [tree]);
      if (fn) {
        fn();
      }
    }
    var cacheName = this.getPlaceholder();
    var bufferToStringName = this.getPlaceholder() + _constants.predictableFunctionTag;

    // This helper functions convert UInt8 Array to UTf-string
    (0, _insert.prepend)(tree, ..._bufferToString.BufferToStringTemplate.compile({
      name: bufferToStringName,
      getGlobalFnName: this.getPlaceholder() + _constants.predictableFunctionTag
    }));
    for (var functionObject of this.functionObjects) {
      var {
        block,
        fnName: getterFnName,
        encodingImplementation
      } = functionObject;
      var decodeFn = this.getPlaceholder() + _constants.predictableFunctionTag + _constants.criticalFunctionTag;
      (0, _insert.append)(block, encodingImplementation.template.single({
        __fnName__: decodeFn,
        __bufferToString__: bufferToStringName
      }));
      // All these are fake and never ran
      var ifStatements = (0, _template.default)(`if ( z == x ) {
          return y[${cacheName}[z]] = ${getterFnName}(x, y);
        }
        if ( y ) {
          [b, y] = [a(b), x || z]
          return ${getterFnName}(x, b, z)
        }
        if ( z && a !== ${decodeFn} ) {
          ${getterFnName} = ${decodeFn}
          return ${getterFnName}(x, -1, z, a, b)
        }
        if ( a === ${getterFnName} ) {
          ${decodeFn} = y
          return ${decodeFn}(z)
        }
        if( a === undefined ) {
          ${getterFnName} = b
        }
        if( z == a ) {
          return y ? x[b[y]] : ${cacheName}[x] || (z=(b[x] || a), ${cacheName}[x] = z(${this.arrayName}[x]))
        }
        `).compile();

      // Not all fake if-statements are needed
      ifStatements = ifStatements.filter(() => (0, _random.chance)(50));

      // This one is always used
      ifStatements.push((0, _template.default)(`
      if ( x !== y ) {
        return b[x] || (b[x] = a(${this.arrayName}[x]))
      }
      `).single());
      (0, _random.shuffle)(ifStatements);
      var varDeclaration = (0, _template.default)(`
      var ${getterFnName} = (x, y, z, a, b)=>{
        if(typeof a === "undefined") {
          a = ${decodeFn}
        }
        if(typeof b === "undefined") {
          b = ${cacheName}
        }
      }
      `).single();
      varDeclaration.declarations[0].init.body.body.push(...ifStatements);
      (0, _insert.prepend)(block, varDeclaration);
    }
    (0, _insert.prepend)(tree, (0, _gen.VariableDeclaration)([(0, _gen.VariableDeclarator)(cacheName, (0, _gen.ArrayExpression)([])), (0, _gen.VariableDeclarator)(this.arrayName, this.arrayExpression)]));
  }
  match(object, parents) {
    return object.type == "Literal" && typeof object.value === "string" && object.value.length >= 3 && !(0, _compare.isModuleSource)(object, parents) && !(0, _compare.isDirective)(object, parents) //&&
    /*!parents.find((x) => x.$dispatcherSkip)*/;
  }
  transform(object, parents) {
    return () => {
      // Empty strings are discarded
      if (!object.value || this.ignore.has(object.value) || object.value.length == 0) {
        return;
      }

      // Allow user to choose which strings get changed
      if (!(0, _probability.ComputeProbabilityMap)(this.options.stringConcealing, x => x, object.value)) {
        return;
      }
      var currentBlock = (0, _traverse.getBlock)(object, parents);

      // Find created functions
      var functionObjects = parents.filter(node => node.$stringConcealingFunctionObject).map(item => item.$stringConcealingFunctionObject);

      // Choose random functionObject to use
      var functionObject = (0, _random.choice)(functionObjects);
      if (!functionObject || !(0, _encoding.hasAllEncodings)() && (0, _random.chance)(25 / this.functionObjects.length) && !currentBlock.$stringConcealingFunctionObject) {
        // No functions, create one

        var newFunctionObject = {
          block: currentBlock,
          encodingImplementation: (0, _encoding.createEncodingImplementation)(),
          fnName: this.getPlaceholder() + _constants.predictableFunctionTag
        };
        this.functionObjects.push(newFunctionObject);
        currentBlock.$stringConcealingFunctionObject = newFunctionObject;
        functionObject = newFunctionObject;
      }
      var {
        fnName,
        encodingImplementation
      } = functionObject;
      var index = -1;

      // String already decoded?
      if (this.set.has(object.value)) {
        var row = this.index[object.value];
        if (parents.includes(row[2])) {
          [index, fnName] = row;
          (0, _assert.ok)(typeof index === "number");
        }
      }
      if (index == -1) {
        // The decode function must return correct result
        var encoded = encodingImplementation.encode(object.value);
        if (encodingImplementation.decode(encoded) !== object.value) {
          this.ignore.add(object.value);
          this.warn(encodingImplementation.identity, object.value.slice(0, 100));
          delete _encoding.EncodingImplementations[encodingImplementation.identity];
          return;
        }
        this.arrayExpression.elements.push((0, _gen.Literal)(encoded));
        index = this.arrayExpression.elements.length - 1;
        this.index[object.value] = [index, fnName, currentBlock];
        this.set.add(object.value);
      }
      (0, _assert.ok)(index != -1, "index == -1");
      var callExpr = (0, _gen.CallExpression)((0, _gen.Identifier)(fnName), [(0, _gen.Literal)(index)]);

      // use `.apply` to fool automated de-obfuscators
      if ((0, _random.chance)(10)) {
        callExpr = (0, _gen.CallExpression)((0, _gen.MemberExpression)((0, _gen.Identifier)(fnName), (0, _gen.Literal)("apply"), true), [(0, _gen.Identifier)("undefined"), (0, _gen.ArrayExpression)([(0, _gen.Literal)(index)])]);
      }

      // use `.call`
      else if ((0, _random.chance)(10)) {
        callExpr = (0, _gen.CallExpression)((0, _gen.MemberExpression)((0, _gen.Identifier)(fnName), (0, _gen.Literal)("call"), true), [(0, _gen.Identifier)("undefined"), (0, _gen.Literal)(index)]);
      }
      var referenceType = "call";
      if (parents.length && (0, _random.chance)(50 - this.variablesMade)) {
        referenceType = "constantReference";
      }
      var newExpr = callExpr;
      if (referenceType === "constantReference") {
        // Define the string earlier, reference the name here
        this.variablesMade++;
        var constantReferenceType = (0, _random.choice)(["variable", "array", "object"]);
        var place = currentBlock;
        if (!place) {
          this.error(new Error("No lexical block to insert code"));
        }
        switch (constantReferenceType) {
          case "variable":
            var name = this.getPlaceholder();
            (0, _insert.prepend)(place, (0, _gen.VariableDeclaration)((0, _gen.VariableDeclarator)(name, callExpr)));
            newExpr = (0, _gen.Identifier)(name);
            break;
          case "array":
            if (!place.$stringConcealingArray) {
              place.$stringConcealingArray = (0, _gen.ArrayExpression)([]);
              place.$stringConcealingArrayName = this.getPlaceholder();
              (0, _insert.prepend)(place, (0, _gen.VariableDeclaration)((0, _gen.VariableDeclarator)(place.$stringConcealingArrayName, place.$stringConcealingArray)));
            }
            var arrayIndex = place.$stringConcealingArray.elements.length;
            place.$stringConcealingArray.elements.push(callExpr);
            var memberExpression = (0, _gen.MemberExpression)((0, _gen.Identifier)(place.$stringConcealingArrayName), (0, _gen.Literal)(arrayIndex), true);
            newExpr = memberExpression;
            break;
          case "object":
            if (!place.$stringConcealingObject) {
              place.$stringConcealingObject = (0, _gen.ObjectExpression)([]);
              place.$stringConcealingObjectName = this.getPlaceholder();
              (0, _insert.prepend)(place, (0, _gen.VariableDeclaration)((0, _gen.VariableDeclarator)(place.$stringConcealingObjectName, place.$stringConcealingObject)));
            }
            var propName = this.gen.generate();
            var property = (0, _gen.Property)((0, _gen.Literal)(propName), callExpr, true);
            place.$stringConcealingObject.properties.push(property);
            var memberExpression = (0, _gen.MemberExpression)((0, _gen.Identifier)(place.$stringConcealingObjectName), (0, _gen.Literal)(propName), true);
            newExpr = memberExpression;
            break;
        }
      }
      this.replaceIdentifierOrLiteral(object, newExpr, parents);
    };
  }
}
exports.default = StringConcealing;